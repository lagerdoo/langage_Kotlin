<!doctype html>
<html lang="en">
	<head>
        <title>About Kotlin</title>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">


        <!-- Main CSS --> 
        <link rel="stylesheet" href="./assets/css/style.css">

        <!-- Font Awesome -->
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
        
    </head>
  
    <body>

        <!-- Main navigation -->
        <div id="sidebar">
                      
            <div class="navbar-expand-md navbar-dark"> 
            
                <header class="d-none d-md-block">
                   	<h1>Kotlin</h1>
                </header>
                
                
                <!-- Mobile menu toggle and header -->
                <div class="mobile-header-controls">
                    <a class="navbar-brand d-md-none d-lg-none d-xl-none" href="#"><span>my</span>website</a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#SidebarContent" aria-controls="SidebarContent" aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>
                </div>
         
                <div id="SidebarContent" class="collapse flex-column navbar-collapse">
 
                        
                    
                    <!-- Main navigation items -->
                    <nav class="navbar navbar-dark">
                        <div id="mainNavbar">
                            <ul class="flex-column mr-auto">
                                <li class="nav-item">
                                        <a class="nav-link" href="index.html">Home <span class="sr-only">(current)</span></a>
                                </li>

                                <li class="nav-item active dropdown">
                                            <a class="nav-link dropdown-toggle" href="#MenuDropdown" data-toggle="collapse" aria-controls="MenuDropdown" aria-expanded="false">About Kotlin</a>
                                            <ul id="MenuDropdown" class="sub-navbar collapse flex-column">
						     <li class="nav-item"><a class="nav-link" href="Overview.html">Overview</a></li>
                                                <li class="nav-item active dropdown">
                                           			 <a class="nav-link dropdown-toggle" href="#MenuDropdown1" data-toggle="collapse" aria-controls="MenuDropdown1" aria-expanded="false">Basics of Kotlin languages</a>
                                            			<ul id="MenuDropdown1" class="sub-navbar collapse flex-column">
                                            				<li class="nav-item"><a class="nav-link" href="Basics.html">  Basic Types</a></li> 
                                            				<li class="nav-item"><a class="nav-link" href="Control Flow.html">  Control Flow</a></li> 
                                            			</ul>
                                            		<li class="nav-item active dropdown">
                                                <li class="nav-item"><a class="nav-link" href="Main_standard.html">Main standard libraries</a></li>
                                                <li class="nav-item"><a class="nav-link" href="Major_third.html">Major third-party libraries</a></li>
                                                <li class="nav-item"><a class="nav-link"  href="Development.html">Development tools</a></li>
                                                <li class="nav-item"><a class="nav-link"  href="Learning.html">Learning resources</a></li>
                                            </ul>
                                </li>
                                <li class="nav-item">
                                        <a class="nav-link" href="#">Contact</a>
                                </li>
                            </ul>
                        </div>   
                    </nav>
                
                
                
                    <!-- Sidebar search form -->
                    <form class="form-inline sidebar-search-form my-2 my-lg-0">
                        <input class="form-control mr-sm-2" type="text" size="10"  placeholder="Search" aria-label="Search">
                        <button class="btn my-2 my-sm-0" type="submit">Search</button>
                    </form>
          
                    <!-- Social icons -->
                  <p class="sidebar-social-icons social-icons">
                        <a href="https://twitter.com/kotlin"><i class="fa fa-twitter fa-2x"></i></a>
                    </p>
                
                </div>
            </div> 
        </div>
    
        
        <div id="content">
            <div id="content-wrapper">
                
                <!-- Jumbtron / Slider -->
                <div class="jumbotron-wrap">
                    <div class="container-fluid">
                        <div class="jumbotron jumbotron-narrow static-slider">
                            <h1 class="text-center">Main standard libraries</h1>
                        </div>
                    </div>
                </div>

                <!-- Main content area -->
                <main class="container-fluid">
                    <div class="row">

                        <!-- Main content -->
                        <div class="col-sm-8">
                            <article>
                            <h3>Kotlin/Native libraries</h3>
				    <h5>Kotlin compiler specifics</h5>
				    <p>To produce a library with the Kotlin/Native compiler use the -produce library or -p library flag.
					    For example:</p>
				    
		         <pre>$ kotlinc foo.kt -p library -o bar</pre>
				    
                         <p>the above command will produce a bar.klib with the compiled contents of foo.kt.</p>
				<p>To link to a library use the -library <name> or -l <name> flag. For example:</p>  
					<pre>$ kotlinc qux.kt -l bar</pre>
					<p>the above command will produce a program.kexe out of qux.kt and bar.klib</p>
					
					<h4>cinterop tool specifics</h4>
					<p>The cinterop tool produces .klib wrappers for native libraries as its main output.
					For example, using the simple libgit2.
				        def native library definition file provided in your Kotlin/Native distribution</p>
					
					<pre>$ cinterop -def  samples/gitchurn/src/main/c_interop/libgit2.def -compilerOpts -I/usr/local/include -o libgit2 </pre>
                                        
					<p>we will obtain libgit2.klib.</p>
					<p>See more details in INTEROP.md</p>
					
					<h5>klib utility</h5>
					<p>The klib library management utility allows you to inspect and install the libraries.
                                         The following commands are available.To list library contents:</p>
					
					<pre>$ klib contents <name></pre>
					<p>To inspect the bookkeeping details of the library</p>
					<pre>$ klib info <name></pre>
					<p>To remove the library from the default repository use</p>
					<pre>$ klib remove <name></pre>
					<p>All of the above commands accept an additional -repository <directory> 
					argument for specifying a repository different to the default one.</p>
					<pre>$ klib <command> <name> -repository <directory></pre>
					
					<h4>Several examples</h4>
					<p>First let's create a library. Place the tiny library source code into kotlinizer.kt:</p>
<pre>
	package kotlinizer
	val String.kotlinized
	get() = "Kotlin $this"
	$ kotlinc kotlinizer.kt -p library -o kotlinizer						    
</pre>
				     <p>The library has been created in the current directory:</p> 
					     
<pre>	$ ls kotlinizer.klib 
	kotlinizer.klib
</pre>   					   
					  <p>Now let's check out the contents of the library:</p>
					  <pre>$ klib contents kotlinizer</pre>
					  <p>We can install kotlinizer to the default repository:</p>
					  <pre>$ klib install kotlinizer</pre>
					  <p>Remove any traces of it from the current directory:</p>
					  <pre>$ rm kotlinizer.klib</pre>
					  <p>Create a very short program and place it into a use.kt :</p>
 <pre>
	 import kotlinizer.*
	 fun main(args: Array<String>) {
	 println("Hello, ${"world".kotlinized}!")} 
 </pre>
					  <p>Now compile the program linking with the library we have just created:</p>
					  <pre>$ kotlinc use.kt -l kotlinizer -o kohello</pre>
					  <p>And run the program:</p>
<pre>	$ ./kohello.kexe 
	Hello, Kotlin world!
</pre>
					   
					   <h3> Advanced topics</h3>
					   <h5>Library search sequence</h5>
					   <p>When given a -library foo flag, the compiler searches the foo library in
					   the following order:
                                            * Current compilation directory or an absolute path.
                                            * All repositories specified with `-repo` flag.
                                            * Libraries installed in the default repository
					     (For now the default is  `~/.konan`,
					     however it could be changed by setting **KONAN_DATA_DIR** environment variable).
                                            * Libraries installed in `$installation/klib` directory.</p>
					    
					    
					    <h5>The library format</h5>
					    <p>Kotlin/Native libraries are zip files containing a predefined directory structure,
					     with the following layout:</p>
					     <p>foo.klib when unpacked as foo/ gives us:</p>
<pre>	
	- foo/
	- targets/
	- $platform/
	- kotlin/
	- Kotlin compiled to LLVM bitcode.
	- native/
	- Bitcode files of additional native objects.
	- $another_platform/
	- There can be several platform specific kotlin and native pairs.
	- linkdata/
	- A set of ProtoBuf files with serialized linkage metadata.
	- resources/
	- General resources such as images. (Not used yet).
	- manifest - A file in *java property* format describing the library.
</pre>
					     
					     <p>An example layout can be found in klib/stdlib directory of your installation.</p>
					     
					     <h3>Platform libraries</h3>
					     <h5>Overview</h5>
					     <p>To provide access to user's native operating system services,
					     Kotlin/Native distribution includes a set of prebuilt libraries specific to each target. 
					     We call them Platform Libraries.</p>
					     <h5>POSIX bindings</h5>
					     <p>For all Unix or Windows based targets
					     (including Android and iPhone) we provide the posix platform lib.
					     It contains bindings to platform's implementation of POSIX standard.
                                             To use the library just</p>
					     <pre>import platform.posix.*</pre>
					     <p>The only target for which it is not available is WebAssembly.
                                              Note that the content of platform.posix is NOT identical on different platforms,
                                             in the same way as different POSIX implementations are a little different.</p>
					     <h5>Popular native libraries</h5>
					     <p>There are many more platform libraries available for host and cross-compilation targets.
					     Kotlin/Native distribution provides access to OpenGL, SDL, 
					     zlib and other popular native libraries on applicable platforms.</p>
					     <p>On Apple platforms objc library is provided for interoperability with Objective-C.
					     Inspect the contents of dist/klib/platform/$target of the distribution for the details.</p>
					     <h4>Availability by default</h4>
					     <p>The packages from platform libraries are available by default.
					     No special link flags need to be specified to use them. 
					     Kotlin/Native compiler automatically detects which of the platform libraries 
					     have been accessed and automatically links the needed libraries.</p>
					     <p>On the other hand, the platform libs in the distribution are merely 
					     just wrappers and bindings to the native libraries.
					     That means the native libraries themselves (.so, .a, .dylib, .dll etc)
					     should be installed on the machine.</p>
					     
					     <h3>Keep Your API Small</h3>
					     <p>Giving an API to your users is similar to asking someone to hit a target with an arrow.
					     The smaller the target, the harder it is to hit. This is true with libraries as well. 
					     The smaller the API you have, the easier it is to maintain, 
					     and you also minimize the chance that you accidentally expose something which you didn't intend to.
					     Take this API for example:
					     In the following examples we're going to work on an imaginary library 
					     which exposes an API for handling UI widgets.</p>
					     
<pre>class MyComponent(
	val isFocused: Boolean,
	val children: List<MyComponent>,
	val drawSurface: PixelGraphicsImpl) {
	fun requestFocus() {
	}
	fun clearFocus() {
	}
	fun render() {
	}
	fun attachTo(container: Container) { 
	} }
</pre>
						  <p>Here we expose the MyComponent class which has a property to tell whether it is focused,
						  it exposes its children, and also the draw surface which is used for rendering.
                                                  There are a lot of cases when you might have the feeling that you need to expose
						  things because you think that it might be useful for you users. 
						  What actually happens most of the time is that you expose too much,
						  your users start to rely on them and later 
						  when you figure out that some of the internals of your library 
						  need to be refactored you have to break the API for your users if you want to fix it. 
						  Let's take a look at the same class with a smaller API:</p>
 <pre>class MyComponent(
	val children: List<MyComponent>, // 1
	internal val drawSurface: PixelGraphicsImpl) { // 2
	fun requestFocus(){
	}
	fun clearFocus(){ 
	}
	internal fun render() { // 3
	}
	internal fun attachTo(container: Container) {
	}
	}</pre>
						       <p>So after evaluating our class it turns out that
                                                          isFocused was not needed at all and we only want our users 
							  to be able to either clear or request the focus. 
							  With this we preserved the same functionality but retained the ability 
							  to handle focus in any way we wish.
                                                          drawSurface is something which we take as a dependency,
							  but it is internal to our library so we shouldn't allow the external world
							  to tamper with it. 
							  It happens quite often that users start to use 
							  things which you exposed in ways you didn't intend it 
							  to work so this helps with that problem.
                                                          It also turns out that render and attachTo had the same problem
							  as drawSurface: they are internal to the library and the users shouldn't do
							  rendering or component (re)attaching by hand.
                                                          Let's take this a step further by introducing better abstractions.</p>
							  <h4>Keep Your API Abstract and Clean</h4>
							  In the previous example we've cleaned up parts of our API and removed / 
							  hid some things which were not intended to be public.
							  Now we'll take a look at things we do expose:
<pre>class MyComponent(
	val children: Iterable<Component>, // 1
	internal val drawSurface: DrawSurface) { // 2
	fun requestFocus() {
	}
	fun clearFocus() {
	}
	internal fun render() {
	}
	internal fun attachTo(container: Container) {
	}
	}</pre>
                                                               <p>After careful investigation we concluded that:
                                                                  We don't really need the functionality Lists provide 
								  for our children and an Iterable will suffice.
                                                                  A good example for this is that if you expose a List of 
								  something which your users just want to iterate over with
								  a for loop you either lose the ability to construct items 
								  on the fly or make it much harder to implement.
                                                                  With an Iterable or a Sequence you can do this easily. 
								  It also enables you to return an insanely high number of elements
								  without filling up the memory.
                                                                  As it turns out PixelGraphicsImpl is a concrete implementation 
								  of DrawSurface and it has some internal things which 
								  we don't want to expose. 
								  It can become problematic if we expose implementation classes 
								  through the API and make it impossible to change the implementation
								  behind the scenes without breaking your users' code.
                                                                  All of these lead us to the realization that to clean up 
								  this mess we should start to...</p>
								  
 <h3>Use Interfaces</h3>
								  <p>By taking a hard look at what we have, we can conclude that exposing classes
								  and concrete implementations through our API will lead to all sorts of problems, 
								  so using interfaces is a better approach overall:</p>
<pre>interface Component {
	val children: Iterable<Component>
	fun requestFocus()
	fun clearFocus()
	}
	class MyComponent(
	override val children: Iterable<Component>,
	val drawSurface: DrawSurface) : Component {
	override fun requestFocus() {
	}                                                                      
	override fun clearFocus() {
	}                                                                        
	fun render() {
	}
	fun attachTo(container: Container) {
	}
	}</pre>
			                                                <p>This way we are free to implement Component as we see fit.
									We can have any number of implementations for it if we want and it won't affect our users.
									An important caveat for this is to only return abstract types from our factories:</p>
									
<pre>object ComponentFactory {
	fun createComponent(
	children: Iterable<Component>,
	drawSurface: DrawSurface): Component {
	return MyComponent(
	children = children,
	drawSurface = drawSurface)
	}
	}</pre>
													   
							                    <p>This might seem obvious, but this is often overlooked.</p>
 					                                    <h4>The Modularization Problem</h4>
									    <p>So we separated our API and our concrete implementations into 
									    interfaces and classes.
									    The problem is that we can't prevent our users from circumventing 
									    our clean API and using MyComponent directly since Kotlin
									    doesn't have its own module system.
									    What we can do is to separate our packages 
									    into api and internal (or anything similar) and clearly state
									    in the documentation that everything in internal is subject to change:</p>
 <pre>// safe to use
 	package api
	interface Component
	interface DrawSurface
	interface Container
	// use them at your own risk!
	package internal
	class MyComponent : Component
	class ThreadSafeComponent: Component
	class PixelGraphicsImpl : DrawSurface
	class DefaultContainer : Container
	</pre>
	
	<p>This solution is not perfect, but it helps.</p>
										   <h4>Kotlin Tips</h4>
										   <p>We've discussed a lot of things already, 
										      but we haven't seen any Kotlin-specific tips yet, 
										      so let's take a look at some!</p>
										   <h4>Add a companion object</h4>
										   <p>It might be a case that you don't use companion objects in your
										      project or you don't have the need for them in some API classes.
										      What's important to point out here is that companion objects
										      enable your users to define extension functions on your classes 
										      which can be invoked without an instance. 
										      You can add an empty companion object:</p>
 <pre>interface Subscription {
 	fun cancel()
	companion object
	}</pre>
					                                            <p>and your users gain the ability to augment your interface
										       as they see fit:</p>
 <pre>fun Subscription.Companion.create(): Subscription {
 	TODO("Create new Subscription")
	}
	fun useIt() {
	Subscription.create()
	}
	</pre>
									     <h4>Take Extension Functions to the Next Level</h4>
										     <p>Extension functions can also help you to create
										        a more fluent API. Take a look at this example, 
										        where our user has a list of Subscriptions:</p>
											
<pre>	val subscriptions: MutableList<Subscription> = mutableListOf()</pre>
<p>In order to cancel them all, they most probably write 
											   something like this:</p>
<pre>fun cancelAllSubscriptions() {
	subscriptions.forEach {
	it.cancel()
	}
	subscriptions.clear()
	}</pre>
											 <p>But what if we provide this functionality out of the box?</p>
											 <pre>fun <T: Subscription> MutableList<T>.cancelAll() {
											        forEach {
												it.cancel()
												 }
												 clear()
												 }</pre>
											 <p>This way cancelAll can be called on any MutableList which holds Subscriptions:</p>

<pre>fun usage() {
	val subscriptions = mutableListOf<Subscription>()											      subscriptions.cancelAll()
	}</pre>
											      <h4>Have reified Functions Delegate Work</h4>
											      <P>reified functions are very useful but they come with some caveats that are very frustrating.
											      One of them is that we need to use @PublishedApi if we want to access the internals of a class.
											      For this reason it helps greatly if we simply delegate the work from them to functions which take
											      KClass objects as parameters so we get the utility of reified functions without the problems:</p>
											     
<pre>class EventBus {
	private val subscriptions =
	mutableMapOf<KClass<out Any>, (Any) -> Unit>()
	inline fun <reified T : Event> subscribe(
	noinline callback: (T) -> Unit) {
	return subscribe(
	klass = T::class,
	callback = callback)
	}
	fun <T : Event> subscribe(klass: KClass<T>,
	callback: (T) -> Unit) {
	subscriptions[klass] = callback as (Any) -> Unit
	}
	}
	</pre>
	<p>Astute readers might spot the problem with this API.
	We're not using interfaces! Unfortunately interfaces don't support reified functions, 
	but there is a solution which solves this problem:</p>
												      <h4>Let reified Functions be Extension Functions</h4>
												      <p>It is true that we can't have reified functions in an interface:</p>

<pre>interface EventBus {
	fun <T : Event> subscribe(klass: KClass<T>,
	callback: (T) -> Unit)
	}</pre>
												      <p>but we can have reified extension functions:</p>
												     
<pre>inline fun <reified T : Event> EventBus.subscribe(
	noinline callback: (T) -> Unit) {
	return subscribe(
	klass = T::class,
	callback = callback)
	}</pre>
	<p>With this we get the best of both worlds, and usage stays the same:</p>
													   
<pre>fun usage() {
	EventBus().subscribe<Event> {  }
	}</pre>
														<p>The tips above are applicable to any Kotlin
														   project but there is a special kind of project which needs more care than a regular one:</p>
														<h4>Multiplatform Libraries</h4>  
														<p>If you are working on a multiplatform library
														   you need to write code which is idiomatic on all platforms.
														   In the following section we'll take a look at some tips that will help with this.</p>
														   <h5>Use Properties Instead of Getters</h5>
											             <p>Writing a getter (getX) for a property is not idiomatic in Kotlin. On the other hand,
												     accessing fields in Java without getters is not idiomatic either! 
												     It turns out that Kotlin properties are implemented in a way that both sides
												     will see an API they wish to see:</p>

<pre>interface Position {
	val x: Int
	val y: Int
	}
	// idiomatic in Kotlin
	pos.x
	pos.y
	// idiomatic in Java
	pos.getX();												
	pos.getY();
	</pre>

                                <a href="https://kotlinlang.org/docs/reference/native/libraries.html">For more information!</a>
                            </article>
                        </div>
                    </div> 
                    <p class="text-center"><a href="#">Back to top</a></p>
                </main>


                <!-- Footer -->
               
            </div>
        </div>

        <!-- Bootcamp JavaScript -->
        <!-- jQuery first, then Popper.js, then Bootstrap JS -->
        <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

    </body>
</html>
